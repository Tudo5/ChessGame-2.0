<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VSCode Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-900">
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const pieceSets = {
            classic: { wK: "♔", wQ: "♕", wR: "♖", wB: "♗", wN: "♘", wP: "♙", bK: "♚", bQ: "♛", bR: "♜", bB: "♝", bN: "♞", bP: "♟" },
            emerald: { wK: "♚", wQ: "♛", wR: "♜", wB: "♝", wN: "♞", wP: "♟", bK: "♔", bQ: "♕", bR: "♖", bB: "♗", bN: "♘", bP: "♙" },
            ocean: { wK: "🦑", wQ: "🐋", wR: "🦀", wB: "🐠", wN: "🐬", wP: "🐚", bK: "🦑", bQ: "🐋", bR: "🦀", bB: "🐠", bN: "🐬", bP: "🐚" },
            purple: { wK: "👑", wQ: "💎", wR: "🏰", wB: "🔮", wN: "🦄", wP: "⭐", bK: "☠️", bQ: "🌑", bR: "⚔️", bB: "👻", bN: "🐉", bP: "🕸️" },
        };

        const themes = [
            { name: "Classic", key: "classic", light: "linear-gradient(135deg,#f0d9b5,#fff5e1)", dark: "linear-gradient(135deg,#b58863,#8b5e3c)", pieceStyle: { white: { color: "#fff", textShadow: "0 0 2px black" }, black: { color: "#000" } } },
            { name: "Emerald", key: "emerald", light: "linear-gradient(135deg,#d1fae5,#a7f3d0)", dark: "linear-gradient(135deg,#10b981,#065f46)", pieceStyle: { white: { color: "#34d399", textShadow: "0 0 3px #064e3b" }, black: { color: "#064e3b" } } },
            { name: "Ocean", key: "ocean", light: "linear-gradient(135deg,#e0f2fe,#bae6fd)", dark: "linear-gradient(135deg,#0284c7,#075985)", pieceStyle: { white: { color: "#38bdf8", textShadow: "0 0 3px #0c4a6e" }, black: { color: "#0c4a6e" } } },
            { name: "Purple", key: "purple", light: "linear-gradient(135deg,#ede9fe,#ddd6fe)", dark: "linear-gradient(135deg,#7c3aed,#4c1d95)", pieceStyle: { white: { color: "#c4b5fd", textShadow: "0 0 3px #312e81" }, black: { color: "#312e81" } } }
        ];

        const initialBoard = () => {
            const empty = Array(8).fill(null).map(() => Array(8).fill(null));
            const back = ["R", "N", "B", "Q", "K", "B", "N", "R"];
            for (let i = 0; i < 8; i++) empty[0][i] = { color: "b", kind: back[i] };
            for (let i = 0; i < 8; i++) empty[1][i] = { color: "b", kind: "P" };
            for (let i = 0; i < 8; i++) empty[6][i] = { color: "w", kind: "P" };
            for (let i = 0; i < 8; i++) empty[7][i] = { color: "w", kind: back[i] };
            return empty;
        };

        function cloneBoard(b) { return b.map(r => r.map(c => c ? { ...c } : null)); }

        function getMoves(board, r, c) {
            const cell = board[r][c]; if (!cell) return [];
            const { color, kind } = cell; const dir = color === "w" ? -1 : 1;
            const moves = []; const inB = (x, y) => x >= 0 && x < 8 && y >= 0 && y < 8;
            const push = (x, y) => { if (!inB(x, y)) return; const t = board[x][y]; if (!t || t.color !== color) moves.push([x, y]); };
            if (kind === "P") {
                const one = r + dir, two = r + 2 * dir;
                if (inB(one, c) && !board[one][c]) { moves.push([one, c]); const start = color === "w" ? 6 : 1; if (r === start && inB(two, c) && !board[two][c]) moves.push([two, c]); }
                for (let dy of [-1, 1]) { const x = r + dir, y = c + dy; if (inB(x, y) && board[x][y] && board[x][y].color !== color) moves.push([x, y]); }
            } else if (kind === "N") { for (let [dx, dy] of [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]]) push(r + dx, c + dy); }
            else if (["B", "R", "Q"].includes(kind)) {
                const dirs = []; if (["B", "Q"].includes(kind)) dirs.push([-1, -1], [-1, 1], [1, -1], [1, 1]);
                if (["R", "Q"].includes(kind)) dirs.push([-1, 0], [1, 0], [0, -1], [0, 1]);
                for (let [dx, dy] of dirs) { let x = r + dx, y = c + dy; while (inB(x, y)) { if (!board[x][y]) { moves.push([x, y]); x += dx; y += dy; continue; } if (board[x][y].color !== color) moves.push([x, y]); break; } }
            } else if (kind === "K") { for (let dx = -1; dx <= 1; dx++)for (let dy = -1; dy <= 1; dy++) if (dx || dy) push(r + dx, c + dy); }
            return moves;
        }

        function isKingInCheck(board, color) {
            let kr, kc;
            for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && p.color === color && p.kind === "K") { kr = r; kc = c; } }
            for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && p.color !== color) { const moves = getMoves(board, r, c); if (moves.some(([mr, mc]) => mr === kr && mc === kc)) return true; } }
            return false;
        }

        function hasAnyMoves(board, color) {
            for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && p.color === color) { const moves = getMoves(board, r, c); for (let [mr, mc] of moves) { const nb = cloneBoard(board); nb[mr][mc] = nb[r][c]; nb[r][c] = null; if (!isKingInCheck(nb, color)) return true; } } }
            return false;
        }

        function getGameState(board, turn) {
            const enemy = turn === "w" ? "b" : "w";
            if (!hasAnyMoves(board, turn)) {
                if (isKingInCheck(board, turn)) return { over: true, result: `Мат! Победили ${enemy === "w" ? "Белые" : "Чёрные"}` };
                else return { over: true, result: "Пат!" };
            }
            return { over: false, result: isKingInCheck(board, turn) ? "Шах!" : "" };
        }

        const values = { P: 1, N: 3, B: 3, R: 5, Q: 9, K: 1000 };
        function evaluate(board) { let score = 0; for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (!p) continue; const v = values[p.kind]; score += p.color === "w" ? v : -v; } return score; }

        // 🚀 Альфа-бета с ограничением ветвей
        function minimax(board, depth, maximizing, alpha = -Infinity, beta = Infinity) {
            if (depth === 0) return [evaluate(board), null];
            const color = maximizing ? "w" : "b"; let best = maximizing ? -Infinity : Infinity; let bestMove = null;
            const moves = [];
            for (let r = 0; r < 8; r++)for (let c = 0; c < 8; c++) { const p = board[r][c]; if (!p || p.color !== color) continue; for (let [mr, mc] of getMoves(board, r, c)) { const nb = cloneBoard(board); nb[mr][mc] = nb[r][c]; nb[r][c] = null; if (nb[mr][mc].kind === "P" && (mr === 0 || mr === 7)) nb[mr][mc].kind = "Q"; if (!isKingInCheck(nb, color)) moves.push([[r, c], [mr, mc]]); } }
            const MAX_BRANCHES = 20; const limitedMoves = moves.slice(0, MAX_BRANCHES);
            for (let [[sr, sc], [r, c]] of limitedMoves) {
                const nb = cloneBoard(board); nb[r][c] = nb[sr][sc]; nb[sr][sc] = null;
                const [score] = minimax(nb, depth - 1, !maximizing, alpha, beta);
                if (maximizing) { if (score > best) { best = score; bestMove = [[sr, sc], [r, c]]; } alpha = Math.max(alpha, best); }
                else { if (score < best) { best = score; bestMove = [[sr, sc], [r, c]]; } beta = Math.min(beta, best); }
                if (beta <= alpha) break;
            }
            return [best, bestMove];
        }

        function pieceToUnicode(p, setKey) { return pieceSets[setKey][p.color + p.kind]; }

        function ChessGame() {
            const [board, setBoard] = React.useState(initialBoard());
            const [turn, setTurn] = React.useState("w");
            const [selected, setSelected] = React.useState(null);
            const [history, setHistory] = React.useState([]);
            const [themeIndex, setThemeIndex] = React.useState(0);
            const [mode, setMode] = React.useState("2p");
            const [difficulty, setDifficulty] = React.useState(3);
            const [status, setStatus] = React.useState("");

            const theme = themes[themeIndex];

            const legalTargets = React.useMemo(() => {
                if (!selected) return [];
                const [r, c] = selected;
                return getMoves(board, r, c).map(([x, y]) => `${x},${y}`);
            }, [board, selected]);

            function movePiece(sr, sc, r, c) {
                const nb = cloneBoard(board);
                const p = nb[sr][sc]; nb[sr][sc] = null; nb[r][c] = p;
                if (p.kind === "P" && (r === 0 || r === 7)) p.kind = "Q";
                const nextTurn = turn === "w" ? "b" : "w";
                setBoard(nb); setTurn(nextTurn); setSelected(null);
                setHistory(h => [...h, `${pieceToUnicode(p, theme.key)} → ${String.fromCharCode(97 + c)}${8 - r}`]);
                const state = getGameState(nb, nextTurn);
                setStatus(state.result);
            }

            function onSquareClick(r, c) {
                if (status.includes("Мат") || status.includes("Пат")) return;
                const piece = board[r][c];
                if (selected) {
                    const [sr, sc] = selected;
                    if (legalTargets.includes(`${r},${c}`)) { movePiece(sr, sc, r, c); }
                    else if (piece && piece.color === turn) setSelected([r, c]);
                    else setSelected(null);
                } else if (piece && piece.color === turn) setSelected([r, c]);
            }

            React.useEffect(() => {
                if (mode === "bot" && turn === "b" && !status.includes("Мат") && !status.includes("Пат")) {
                    setTimeout(() => {
                        const [_, move] = minimax(board, difficulty, false);
                        if (move) { const [[sr, sc], [r, c]] = move; movePiece(sr, sc, r, c); }
                    }, 300);
                }
            }, [turn, mode, board, status]);

            function reset() { setBoard(initialBoard()); setTurn("w"); setSelected(null); setHistory([]); setStatus(""); }

            return (
                <div className="p-6 min-h-screen flex items-start justify-center bg-gradient-to-br from-gray-900 to-gray-800 font-sans">
                    <div className="max-w-6xl w-full grid grid-cols-3 gap-6">
                        <div className="col-span-2">
                            <div className="p-4 rounded-xl shadow-xl bg-white/5">
                                <div className="flex justify-between mb-3 text-white">
                                    <h2 className="text-2xl font-semibold">VSCode Chess</h2>
                                    <div>Ход: <b>{turn === "w" ? "Белые" : "Чёрные"}</b></div>
                                </div>
                                {status && <div className="mb-2 p-2 text-center text-lg font-bold bg-red-500/80 rounded">{status} <button onClick={reset} className="ml-3 px-2 py-1 bg-white/20 rounded">Reset</button></div>}
                                <div className="grid grid-cols-8 border rounded-md overflow-hidden" style={{ width: "min(640px,90vw)" }}>
                                    {board.map((row, r) => row.map((cell, c) => {
                                        const isLight = (r + c) % 2 === 0; const isSel = selected && selected[0] === r && selected[1] === c;
                                        const isTgt = legalTargets.includes(`${r},${c}`);
                                        return (
                                            <div key={`${r}-${c}`} onClick={() => onSquareClick(r, c)}
                                                className="relative flex items-center justify-center cursor-pointer select-none aspect-square transition-all"
                                                style={{ background: isLight ? theme.light : theme.dark, outline: isSel ? "3px solid rgba(99,102,241,0.8)" : undefined }}>
                                                {cell && <div className="text-5xl" style={cell.color === "w" ? theme.pieceStyle.white : theme.pieceStyle.black}>{pieceToUnicode(cell, theme.key)}</div>}
                                                {isTgt && <div className="absolute w-4 h-4 rounded-full bg-emerald-500/85"></div>}
                                            </div>
                                        )
                                    }))}
                                </div>
                                <div className="mt-4 flex gap-2 items-center text-white">
                                    <button onClick={reset} className="px-3 py-1 rounded-lg bg-white/10">Reset</button>
                                    <select value={themeIndex} onChange={e => setThemeIndex(+e.target.value)} className="px-3 py-1 rounded-lg bg-white/10 cursor-pointer">
                                        {themes.map((t, i) => <option key={i} value={i}>{t.name}</option>)}
                                    </select>
                                    <select value={mode} onChange={e => setMode(e.target.value)} className="px-3 py-1 rounded-lg bg-white/10 cursor-pointer">
                                        <option value="2p">2 игрока</option>
                                        <option value="bot">Против бота</option>
                                    </select>
                                    {mode === "bot" && (
                                        <select value={difficulty} onChange={e => setDifficulty(+e.target.value)} className="px-3 py-1 rounded-lg bg-white/10 cursor-pointer">
                                            <option value={1}>Лёгкий</option>
                                            <option value={3}>Средний</option>
                                            <option value={5}>Сложный</option>
                                        </select>
                                    )}
                                </div>
                            </div>
                        </div>
                        <div className="col-span-1">
                            <div className="p-4 rounded-xl shadow-xl bg-white/5 h-full">
                                <h3 className="text-white font-semibold mb-2">История ходов</h3>
                                <div className="h-96 overflow-auto text-sm text-gray-200 p-2 bg-black/20 rounded">
                                    {history.length === 0 && <div className="text-gray-400">Пока нет ходов</div>}
                                    {history.map((h, i) => <div key={i} className="border-b border-white/5 py-1">{i + 1}. {h}</div>)}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<ChessGame />);
    </script>
</body>

</html>
